/**
 * Abstract representation of a selected bucket.
 *
 */
export class Bucket {
  /**
   * Constructor.
   *
   * @param  {KintoClient} client The client instance.
   * @param  {String}      name   The bucket name.
   */
  constructor(client, name) {
    /**
     * @ignore
     */
    this.client = client;
    /**
     * The bucket name.
     * @type {String}
     */
    this.name = name;
  }

  /**
   * Selects a collection.
   *
   * @param  {String} name The collection name.
   * @return {Collection}
   */
  collection(name) {
    return new Collection(this.client, this, name);
  }


  /**
   * Retrieves bucket properties.
   *
   * @param  {Object} options The options object.
   * @return {Promise<Object, Error>}
   */
  getProperties(options) {
    return this.client.getBucket(this.name, options);
  }

  /**
   * Retrieves the list of collections in the current bucket.
   *
   * @param  {Object} options The options object.
   * @return {Promise<Array<Object>, Error>}
   */
  listCollections(options) {
    return this.client.listCollections(this.name, {
      ...options,
      bucket: this.name
    });
  }

  /**
   * Creates a new collection in current bucket:
   *
   * - To create a named collection, pass it the name as a first argument.
   * - To have a name generated by the server, simply omit the first argument.
   *
   * The last argument can be an options object in both cases.
   *
   * @param  {...Any} args The function arguments.
   * @return {Promise<Object, Error>}
   */
  createCollection(...args) {
    let createOptions = {bucket: this.name};
    if (typeof args[0] === "string") {
      createOptions.id = args[0];
      if (typeof args[1] === "object") {
        createOptions = {...args[1], ...createOptions};
      }
    } else {
      createOptions = {...args[0], ...createOptions};
    }
    return this.client.createCollection(createOptions);
  }

  /**
   * Deletes a collection from the current bucket.
   *
   * @param  {String} id      The collection id.
   * @param  {Object} options The options object.
   * @return {Promise<Object, Error>}
   */
  deleteCollection(id, options) {
    return this.client.deleteCollection(id, {
      ...options,
      bucket: this.name
    });
  }

  /**
   * Retrieves the list of permissions for this bucket.
   *
   * @param  {Object} options The options object.
   * @return {Promise<Object, Error>}
   */
  getPermissions(options) {
    return this.getProperties(options)
      .then(res => res.permissions);
  }

  /**
   * Recplaces all existing bucket permissions with the ones provided.
   *
   * @param {String} type        The permissions type, "write" or "read".
   * @param {Object} permissions The permissions object.
   * @param {Object} options     The options object
   * @return {Promise<Object, Error>}
   */
  setPermissions(permissions, options) {
    return this.client.updateBucket(this.name, {}, {
      ...options,
      permissions,
    });
  }
}

/**
 * Abstract representation of a selected collection.
 *
 */
export class Collection {
  /**
   * Constructor.
   *
   * @param  {KintoClient}  client The client instance.
   * @param  {Bucket}       bucket The bucket instance.
   * @param  {String}       name   The collection name.
   */
  constructor(client, bucket, name) {
    /**
     * @ignore
     */
    this.client = client;
    /**
     * @ignore
     */
    this.bucket = bucket;
    /**
     * The collection name.
     * @type {String}
     */
    this.name = name;
  }

  /**
   * Retrieves collection properties.
   *
   * @param  {Object} options The options object.
   * @return {Promise<Object, Error>}
   */
  getProperties(options) {
    return this.client.getCollection(this.name, {
      ...options,
      bucket: this.bucket.name
    });
  }

  /**
   * Retrieves the list of permissions for this collection.
   *
   * @param  {Object} options The options object.
   * @return {Promise<Object, Error>}
   */
  getPermissions(options) {
    return this.getProperties(options)
      .then(res => res.permissions);
  }

  /**
   * Replaces all existing collection permissions with the ones provided.
   *
   * @param {String} type        The permissions type, "write" or "read".
   * @param {Object} permissions The permissions object.
   * @param {Object} options     The options object
   * @return {Promise<Object, Error>}
   */
  setPermissions(permissions, options) {
    return this.client.updateCollection(this.name, {}, {
      ...options,
      permissions,
      bucket: this.bucket.name
    });
  }

  /**
   * Retrieves the JSON schema for this collection, if any.
   *
   * @param  {Object} options The options object.
   * @return {Promise<Object|null, Error>}
   */
  getSchema(options) {
    return this.getProperties(options)
      .then(res => res.data && res.data.schema || null);
  }

  /**
   * Sets the JSON schema for this collection.
   *
   * @param  {Object} schema  The JSON schema object.
   * @param  {Object} options The options object.
   * @return {Promise<Object|null, Error>}
   */
  setSchema(schema, options) {
    return this.client.updateCollection(this.name, {}, {
      ...options,
      schema,
      bucket: this.bucket.name
    });
  }

  /**
   * Retrieves metadata attached to current collection.
   *
   * @param  {Object} options The options object.
   * @return {Promise<Object, Error>}
   */
  getMetas(options) {
    return this.getProperties(options)
      .then(res => {
        // XXX move this to utils
        return Object.keys(res.data).reduce((acc, key) => {
          if (key !== "schema") {
            acc[key] = res.data[key];
          }
          return acc;
        }, {});
      });
  }

  /**
   * Sets metadata for current collection.
   *
   * @param  {Object} metas   The metadata object.
   * @param  {Object} options The options object.
   * @return {Promise<Object, Error>}
   */
  setMetas(metas, options) {
    return this.client.updateCollection(this.name, metas, {
      ...options,
      patch: true,
      bucket: this.bucket.name
    });
  }

  /**
   * Creates a record in current collection.
   *
   * @param  {Object} record  The record to create.
   * @param  {Object} options The options object.
   * @return {Promise<Object, Error>}
   */
  createRecord(record, options) {
    return this.client.createRecord(this.name, record, {
      ...options,
      bucket: this.bucket.name
    });
  }

  /**
   * Updates a record in current collection.
   *
   * @param  {Object} record  The record to update.
   * @param  {Object} options The options object.
   * @return {Promise<Object, Error>}
   */
  updateRecord(record, options) {
    return this.client.updateRecord(this.name, record, {
      ...options,
      bucket: this.bucket.name
    });
  }

  /**
   * Deletes a record from the current collection.
   *
   * @param  {String} id      The record id to delete.
   * @param  {Object} options The options object.
   * @return {Promise<Object, Error>}
   */
  deleteRecord(id, options) {
    return this.client.deleteRecord(this.name, id, {
      ...options,
      bucket: this.bucket.name
    });
  }

  /**
   * Retrieves a record from the current collection.
   *
   * @param  {String} id      The record id to retrieve.
   * @param  {Object} options The options object.
   * @return {Promise<Object, Error>}
   */
  getRecord(id, options) {
    return this.client.getRecord(this.name, id, {
      ...options,
      bucket: this.bucket.name
    });
  }

  /**
   * Lists records from the current collection.
   *
   * @param  {Object} options The options object.
   * @return {Promise<Array<Object>, Error>}
   */
  listRecords(options) {
    return this.client.listRecords(this.name, {
      ...options,
      bucket: this.bucket.name
    })
      .then(res => res.data);
  }

  /**
   * Performs batch operations at the current collection level.
   *
   * @param  {Function} fn      The batch operation function.
   * @param  {Object}   options The options object.
   * @return {Promise<Object, Error>}
   */
  batch(fn, options) {
    return this.client.batch(fn, {
      ...options,
      collection: this.name,
      bucket: this.bucket.name
    });
  }
}
